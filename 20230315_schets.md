# Schets 2023-03-15

## Introductie: wat is rust (Rik)
* Systeemtaal, vervanger C
* Moderne taal: generics
* Geen Garbage Collector
* Niet objectgeorienteerd
* Multi platform (inclusief Wasm en Arduino)
* Procedureel met funcionele invloeden
* Zero cost abstractions

## Introductie sprekers

* Wij introduceren onszelf

## Introductie voorbeeld (Rik)

## Voorbeeld (Mart)

``` rust
fn count(counter: &i32) -> &i32
{
    *counter = *counter + 1;
    println!("Counter is {counter}");
    counter
}

fn main()
{
    let counter = 0;
    let counter_ret = count(&counter);
    count(&counter);
    count(counter_ret);
}
```

Oplossen door mut toe te voegen

``` rust
fn count(counter: &mut i32) -> &mut i32
{
    *counter = *counter + 1;
    println!("Counter is {counter}");
    counter
}

fn main()
{
    let mut counter = 0;
    let mut counter_ret = count(&mut counter);
    count(&mut counter);
    count(counter_ret);
}
```

Oplossen door return niet op te slaan

``` rust
fn count(counter: &mut i32) -> &mut i32
{
    *counter = *counter + 1;
    println!("Counter is {counter}");
    counter
}

fn main()
{
    let mut counter = 0;
    count(&mut counter);
    count(&mut counter);
    count(&mut counter);
}
```

## Borrow checker (Mart)
* Compile time memory safety
* 1 bewerkbare instantie of meerdere niet-bewerkbare instanties
* Eigenaarschap: wie is verantwoordelijk voor de data
* (Undefined behaviour)

## Functionele eis modulo 3 (Rik)

``` rust
#[derive(Clone, Debug)]
enum Mod3<T = ()> where T: Default
{
    Een(T),
    Twee,
    Drie(Rc<i32>),
}

impl<T: Default> Mod3<T>
{
    fn next(&mut self)
    {
        match *self
        {
            Mod3::Een(_) => *self = Mod3::Twee,
            Mod3::Twee => *self = Mod3::Drie(Rc::new(0)),
            Mod3::Drie(_) => *self = Mod3::Een(T::default()),
        }
    }
}

fn count(counter: &mut Mod3)
{
    counter.next();
    println!("Counter is {:?}", counter);
}

fn main()
{
    let mut counter = Mod3::Een(());
    count(&mut counter);
    count(&mut counter);
    count(&mut counter);
}
```

## Treading (Rik)

``` rust
fn count(counter: &mut Mod3)
{
    counter.next();
    println!("Counter is {:?}", counter);
}

fn main()
{
    let mut counter = Mod3::Een(());
    count(&mut counter);
    count(&mut counter);
    thread::spawn(|| count(&mut counter));
}
```

Oplossing: move counter in de lambda

``` rust
fn count(counter: &mut Mod3)
{
    counter.next();
    println!("Counter is {:?}", counter);
}

fn main()
{
    let mut counter = Mod3::Een(());
    count(&mut counter);
    count(&mut counter);
    thread::spawn(move || count(&mut counter));
}
```

!Send: oplossing maak send

``` rust
fn count(counter: &mut Mod3)
{
    counter.next();
    println!("Counter is {:?}", counter);
}

fn main()
{
    let mut counter = Mod3::Een(());
    count(&mut counter);
    count(&mut counter);
    thread::spawn(move || count(&mut counter)).join();
}
```

Betere oplossing: maak thread-safe

``` rust
#[derive(Clone, Debug)]
enum Mod3<T = ()> where T: Default
{
    Een(T),
    Twee,
    Drie(Arc<i32>),
}

impl<T: Default> Mod3<T>
{
    fn next(&mut self)
    {
        match *self
        {
            Mod3::Een(_) => *self = Mod3::Twee,
            Mod3::Twee => *self = Mod3::Drie(Arc::new(0)),
            Mod3::Drie(_) => *self = Mod3::Een(T::default()),
        }
    }
}
```

Maar counter niet te verplaatsen in twee threads:
``` rust
fn main()
{
    let mut counter = Mod3::Een(());
    count(&mut counter);
    let handle2 = thread::spawn(move || count(&mut counter));
    let handle3 = thread::spawn(move || count(&mut counter));
    handle2.join();
    handle3.join();
}
```

## Structs (Mart)

``` rust
#[derive(Clone, Debug)]
struct Mod3
{
    value: i32
}

impl Mod3
{
    fn next(&mut self)
    {
        self.value = (self.value % 3) + 1;
    }
}

fn count(counter: &mut Mod3)
{
    counter.next();
    println!("Counter is {:?}", counter);
}

fn main()
{
    let mut counter = Mod3 { value: 1 };
    count(&mut counter);
    count(&mut counter);
    thread::spawn(move || count(&mut counter)).join();
}
```

Voorbeeld met structs

``` rust
#[derive(Clone, Debug)]
struct Mod3
{
    value: i32
}

trait Optellen
{
    type Input: Copy;

    fn optellen(&mut self, input: Self::Input);
}

impl Optellen for Mod3
{
    type Input = ();
    
    fn optellen(&mut self, input: Self::Input)
    {
        self.value = (self.value % 3) + 1;
    }
}

fn count(counter: &mut Mod3)
{
    counter.optellen(());
    println!("Counter is {:?}", counter);
}

fn main()
{
    let mut counter = Mod3 { value: 1 };
    count(&mut counter);
    count(&mut counter);
    thread::spawn(move || count(&mut counter)).join();
}
```

## Wat moet je weten (Rik)
* Sterker getypeerd dan C# / Java
* Mindset
* Bewust zijn van de kosten van oplossingen
